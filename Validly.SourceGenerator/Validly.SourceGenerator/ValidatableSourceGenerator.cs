using System.Diagnostics;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using Validly.SourceGenerator.Builders;
using Validly.SourceGenerator.Dtos;
using Validly.SourceGenerator.Utils;
using Validly.SourceGenerator.Utils.Mapping;
using Validly.SourceGenerator.Utils.SourceTexts;
using Validly.SourceGenerator.Utils.SourceTexts.FileBuilders;
using Validly.SourceGenerator.ValueProviders;

namespace Validly.SourceGenerator;

[Generator]
public class ValidatableSourceGenerator : IIncrementalGenerator
{
	public void Initialize(IncrementalGeneratorInitializationContext initContext)
	{
		var allValidators = ValidatorsIncrementalValueProvider.Get(initContext);
		var validatableObjects = ValidatableObjectIncrementalValueProvider.Get(initContext);
		var config = ConfigOptionsProvider.Get(initContext);

		initContext.RegisterSourceOutput(
			validatableObjects
				.Combine(config)
				.Combine(allValidators)
				.Select((tuple, _) => (tuple.Left.Left, tuple.Left.Right, tuple.Right)),
			ExecuteValidatorGeneration
		);
	}

	private static void ExecuteValidatorGeneration(
		SourceProductionContext context,
		(
			ObjectProperties Object,
			ValidlyConfiguration Config,
			EquatableArray<ValidatorProperties> Validators
		) properties
	)
	{
		var methods = properties
			.Object.Methods.GroupBy(x => x.MethodName)
			.ToDictionary(x => x.Key, group => group.First());

		// Name of the class with RULEs
		string rulesClassName = $"{properties.Object.Name}Rules";
		string customValidatorInterfaceName = $"I{properties.Object.Name}CustomValidation";

		var dependencies = new DependenciesTracker();
		AppendDependenciesOfBeforeAndAfterMethods(properties.Object, dependencies);

		// Builders
		var rulesClassBuilder = new RulesClassBuilder(rulesClassName);
		var customValidationsInterfaceBuilder = new CustomValidationInterfaceBuilder(
			customValidatorInterfaceName,
			dependencies
		).WithMethods(methods);
		var invocationBuilder = new PropertiesValidationInvocationBuilder(
			rulesClassName,
			dependencies,
			properties.Object.ExitEarly ?? properties.Config.ExitEarly
		);

		// Generate stuff for each property
		foreach (PropertyProperties property in properties.Object.Properties)
		{
			var attributes = ToAttributeList(properties, property);

			// Skip properties without validators
			if (attributes.Count == 0)
			{
				continue;
			}

			ProcessValidatableProperty(
				property,
				properties.Object,
				properties.Validators,
				attributes,
				rulesClassBuilder,
				customValidationsInterfaceBuilder,
				invocationBuilder
			);
		}

		bool isAsync =
			customValidationsInterfaceBuilder.Calls.AnyAsync()
			|| invocationBuilder.Calls.AnyAsync()
			|| (
				(properties.Object.BeforeValidateMethod?.ReturnTypeType ?? ReturnTypeType.None)
				& ReturnTypeType.Awaitable
			) != 0
			|| (
				(properties.Object.AfterValidateMethod?.ReturnTypeType ?? ReturnTypeType.None)
				& ReturnTypeType.Awaitable
			) != 0
			// TODO: Can we handle this differently? How should we check if that type is async validator? For now, we force async behavior if there is any property of Validatable type
			|| properties.Object.Properties.Any(prop => prop.PropertyIsOfValidatableType)
			// TODO: Like above, we force async behavior if the object inherits from Validatable object
			|| properties.Object.InheritsValidatableObject;

		// Generate the validator part for the original object
		// > public partial class Xxx : IValidatable, IInternalValidationInvoker { ... }
		var validatorClassBuilder = DeclarationBuilder
			.CreateClassOrRecord(properties.Object.ClassOrRecordKeyword, properties.Object.Name)
			.SetAccessModifier(properties.Object.Accessibility)
			.AddParent(properties.Object.TypeSymbol.ContainingType)
			.AddUsings(properties.Object.Usings.GetArray() ?? Array.Empty<string>())
			// .SetNamespace(properties.Object.Namespace)
			.Partial()
			.AddInterfaces(Consts.IValidatableGlobalRef)
			.AddInterfaces(Consts.InternalValidationInvokerGlobalRef)
			.AddMember(
				CreateValidateMethod(
					properties,
					dependencies,
					customValidationsInterfaceBuilder.HasAnyMethod(),
					customValidatorInterfaceName,
					invocationBuilder,
					isAsync
				)
			);

		// If custom validation is used, add generated interface to the validator class
		if (customValidationsInterfaceBuilder.HasAnyMethod())
		{
			// Add the interface on validator part of the original object
			validatorClassBuilder.AddInterfaces(customValidatorInterfaceName);
		}

		var parentType = properties.Object.TypeSymbol.ContainingType is not null
			? properties.Object.TypeSymbol.ContainingType
			: null;
		var hasParentType = parentType is not null;

		var sourceText =
			"// <auto-generated/>"
			+ Environment.NewLine
			+ "#nullable enable"
			+ Environment.NewLine
			+ Environment.NewLine
			+ (
				properties.Object.Namespace is null
					? string.Empty
					: $"namespace {properties.Object.Namespace}{Environment.NewLine}{{{Environment.NewLine}"
			)
			+ validatorClassBuilder.Build().Indent()
			+ Environment.NewLine
			+ rulesClassBuilder.Build().Indent()
			+ Environment.NewLine
			+ customValidationsInterfaceBuilder.Build().Indent()
			+ Environment.NewLine
			+ (properties.Object.Namespace is null ? string.Empty : "}");

		context.AddSource($"{(hasParentType ? $"{parentType!.Name}.{properties.Object.Name}" : properties.Object.Name)}.Validator.g.cs", SourceText.From(sourceText, Encoding.UTF8));
	}

	private static void AppendDependenciesOfBeforeAndAfterMethods(
		ObjectProperties objectProperties,
		DependenciesTracker dependencies
	)
	{
		if (objectProperties.BeforeValidateMethod is not null)
		{
			foreach (string dependency in objectProperties.BeforeValidateMethod.Dependencies)
			{
				dependencies.AddDependency(dependency);
			}
		}

		if (objectProperties.AfterValidateMethod is not null)
		{
			foreach (string dependency in objectProperties.AfterValidateMethod.Dependencies)
			{
				dependencies.AddDependency(dependency);
			}
		}
	}

	/// <summary>
	/// Create list of validation attributes. Include auto validators if enabled.
	/// </summary>
	/// <param name="properties"></param>
	/// <param name="property"></param>
	/// <returns></returns>
	private static List<AttributeProperties> ToAttributeList(
		(
			ObjectProperties Object,
			ValidlyConfiguration Config,
			EquatableArray<ValidatorProperties> Validators
		) properties,
		PropertyProperties property
	)
	{
		var attributes = property.Attributes.GetArray()?.ToList() ?? new List<AttributeProperties>();

		// Add automatic validators
		AddAutoValidators(attributes, property, properties.Config, properties.Object.UseAutoValidators);

		return attributes;
	}

	private static SourceTextSectionBuilder CreateValidateMethod(
		(
			ObjectProperties Object,
			ValidlyConfiguration Config,
			EquatableArray<ValidatorProperties> Validators
		) properties,
		DependenciesTracker dependencies,
		bool hasCustomValidation,
		string customValidatorInterfaceName,
		PropertiesValidationInvocationBuilder invocationBuilder,
		bool isAsync
	)
	{
		var asyncKeyword = isAsync ? "async " : string.Empty;

		var validateMethodFilePart = new SourceTextSectionBuilder()
			.AppendLine("/// <inheritdoc />")
			.Append($"{asyncKeyword}ValueTask<{Consts.ValidationResultGlobalRef}>")
			.AppendLine($" {Consts.InternalValidationInvokerGlobalRef}.ValidateAsync(")
			.AppendLine($"\t{Consts.ValidationContextGlobalRef} context,")
			.AppendLine($"\t{Consts.ServiceProviderGlobalRef}? serviceProvider")
			.AppendLine(")")
			.AppendLine("{");

		if (hasCustomValidation)
		{
			validateMethodFilePart
				.AppendLine($"\tvar customValidator = ({customValidatorInterfaceName})this;")
				.AppendLine();
		}

		var nestedValidations = new List<string>();
		var nestedValidationsDispose = new List<string>();

		foreach (var property in properties.Object.Properties)
		{
			if (!property.PropertyIsOfValidatableType)
			{
				continue;
			}

			nestedValidations.Add(
				$"""
				context.SetObject(this.{property.PropertyName});
				var nestedValidationResult{nestedValidationsDispose.Count} = await (({Consts.InternalValidationInvokerGlobalRef})this.{property.PropertyName}).ValidateAsync(context, serviceProvider);
				nestedPropertiesCount += (({Consts.InternalValidationResultGlobalRef})nestedValidationResult{nestedValidationsDispose.Count}).GetPropertiesCount();
				"""
			);

			nestedValidationsDispose.Add(
				$"""
				result.CombineNested(nestedValidationResult{nestedValidationsDispose.Count}, "{property.PropertyName}");
				nestedValidationResult{nestedValidationsDispose.Count}.Dispose();
				"""
			);
		}

		var hasNestedProperties = nestedValidations.Count != 0 || properties.Object.InheritsValidatableObject;

		if (hasNestedProperties)
		{
			validateMethodFilePart.AppendLine("\tvar nestedPropertiesCount = 0;");

			if (nestedValidations.Count != 0)
			{
				validateMethodFilePart.AppendLine(
					$"""

					{string.Join(Environment.NewLine, nestedValidations)}
					context.SetObject(this);

					""".Indent(2)
				);
			}

			if (properties.Object.InheritsValidatableObject)
			{
				validateMethodFilePart.AppendLine(
					$"""
					// call BASE class' Validate()
					var baseResult = await (({Consts.InternalValidationInvokerGlobalRef})base).ValidateAsync(validationContext, serviceProvider);
					nestedPropertiesCount += (({Consts.InternalValidationResultGlobalRef})baseResult).GetPropertiesCount();
					""".Indent()
				);
			}
		}

		validateMethodFilePart.AppendLine(
			$"\tvar result = ({Consts.InternalValidationResultGlobalRef}){Consts.ExtendableValidationResultGlobalRef}.Create({properties.Object.Properties.Count}{(hasNestedProperties ? " + nestedPropertiesCount" : string.Empty)});"
		);

		if (nestedValidations.Count != 0)
		{
			validateMethodFilePart.AppendLine(
				$"""

				// Dispose nested validation results
				{string.Join(Environment.NewLine, nestedValidationsDispose)}
				""".Indent(2)
			);
		}

		if (properties.Object.InheritsValidatableObject)
		{
			validateMethodFilePart.AppendLine(
				"""
				result.Combine(baseResult);
				baseResult.Dispose();
				""".Indent(2)
			);
		}

		if (dependencies.HasDependencies)
		{
			validateMethodFilePart
				.AppendLine("\t// Required services")
				.AppendLine("\tvar serviceValidationContext = context;")
				.AppendLine($"\tvar serviceValidationResult = ({Consts.ValidationResultGlobalRef})result;")
				.AppendLine(
					string.Join(
						Environment.NewLine,
						dependencies.Services.Select(dependency =>
							$"\tvar service{dependency} = serviceProvider!.GetRequiredService<{dependency}>();"
						)
					)
				)
				.AppendLine();
		}

		// BeforeValidate hook
		validateMethodFilePart.AppendLine(
			CreateBeforeOrAfterValidateHook(properties.Object.BeforeValidateMethod).Indent(2)
		);

		// Add INVOCATIONS
		validateMethodFilePart.AppendLine(invocationBuilder.Build().Indent(2));

		// AfterValidate hook
		validateMethodFilePart.AppendLine(
			CreateBeforeOrAfterValidateHook(properties.Object.AfterValidateMethod).Indent(2)
		);

		validateMethodFilePart.AppendLine(
			isAsync
				? $"\treturn ({Consts.ValidationResultGlobalRef})result;"
				: $"\treturn new ValueTask<{Consts.ValidationResultGlobalRef}>(({Consts.ValidationResultGlobalRef})result);"
		);

		validateMethodFilePart.AppendLine("}");

		// Explicit implementation of IValidatable
		validateMethodFilePart
			.AppendLine()
			.AppendLine("/// <inheritdoc />")
			.Append(
				$"async ValueTask<{Consts.ValidationResultGlobalRef}> {Consts.IValidatableGlobalRef}.ValidateAsync(IServiceProvider serviceProvider)"
			)
			.AppendLine("{")
			.AppendLine($"\tusing var validationContext = {Consts.ValidationContextGlobalRef}.Create(this);")
			.AppendLine(
				$"\treturn await (({Consts.InternalValidationInvokerGlobalRef})this).ValidateAsync(validationContext, serviceProvider);"
			)
			.AppendLine("}");

		var serviceProviderDep = dependencies.Services.Count > 0 ? "serviceProvider" : "null";

		// Validate() method
		var validateReturnType = isAsync
			? $"ValueTask<{Consts.ValidationResultGlobalRef}>"
			: Consts.ValidationResultGlobalRef;
		var overrideVirtual = properties.Object.InheritsValidatableObject ? "override" : "virtual";
		var serviceProviderParameter =
			dependencies.Services.Count > 0 ? $"{Consts.ServiceProviderGlobalRef} serviceProvider" : string.Empty;

		validateMethodFilePart.AppendLine(
			$$"""

			/// <summary>
			/// Validate the object and get the result with error messages.
			/// </summary>
			/// <returns>Returns disposable ValidationResult.</returns>
			public {{overrideVirtual}} async ValueTask<{{Consts.ValidationResultGlobalRef}}> ValidateAsync({{serviceProviderParameter}})
			{
				using var validationContext = {{Consts.ValidationContextGlobalRef}}.Create(this);
				return await (({{Consts.InternalValidationInvokerGlobalRef}})this).ValidateAsync(validationContext, {{serviceProviderDep}});
			}

			""".Indent()
		);

		if (!isAsync)
		{
			validateMethodFilePart.AppendLine(
				$$"""

				/// <summary>
				/// Validate the object and get the result with error messages.
				/// </summary>
				/// <returns>Returns disposable ValidationResult.</returns>
				public {{overrideVirtual}} {{validateReturnType}} Validate({{serviceProviderParameter}})
				{
					using var validationContext = {{Consts.ValidationContextGlobalRef}}.Create(this);
					var task = (({{Consts.InternalValidationInvokerGlobalRef}})this).ValidateAsync(validationContext, {{serviceProviderDep}});

					if (!task.IsCompletedSuccessfully)
					{
						#if NET7_0_OR_GREATER
						throw new global::System.Diagnostics.UnreachableException("The task should be completed synchronously but was not.");
						#else
						throw new global::System.InvalidOperationException("The task should be completed synchronously but was not.");
						#endif
					}

					return task.Result;
				}

				""".Indent()
			);
		}

		return validateMethodFilePart;
	}

	private static string CreateBeforeOrAfterValidateHook(MethodProperties? method)
	{
		if (method is null)
		{
			return string.Empty;
		}

		var arguments = string.Join(", ", method.Dependencies.Select(service => $"service{service}"));

		if ((method.ReturnTypeType & ReturnTypeType.Void) != 0)
		{
			if ((method.ReturnTypeType & ReturnTypeType.Awaitable) != 0)
			{
				return $"""

					// Call {method.MethodName} hook
					await {method.MethodName}({arguments});
					""";
			}

			return $"""

				// Call {method.MethodName} hook
				{method.MethodName}({arguments});
				""";
		}

		if ((method.ReturnTypeType & ReturnTypeType.ValidationResult) != 0)
		{
			if ((method.ReturnTypeType & ReturnTypeType.Awaitable) != 0)
			{
				return $"""

					// Call {method.MethodName} hook
					var resultOf{method.MethodName} = await {method.MethodName}({arguments});
					if (resultOf{method.MethodName} is not null) return resultOf{method.MethodName};
					""";
			}

			return $"""

				// Call {method.MethodName} hook
				var resultOf{method.MethodName} = {method.MethodName}({arguments});
				if (resultOf{method.MethodName} is not null) return new ValueTask<{Consts.ValidationResultGlobalRef}>(resultOf{method.MethodName});
				""";
		}

		if ((method.ReturnTypeType & ReturnTypeType.AsyncEnumerable) != 0)
		{
			return $"""

				// Call {method.MethodName} hook
				await result.AddAsync({method.MethodName}({arguments}));
				""";
		}

		if ((method.ReturnTypeType & ReturnTypeType.Awaitable) != 0)
		{
			return $"""

				// Call {method.MethodName} hook
				result.Add(await {method.MethodName}({arguments}));
				""";
		}

		return $"""

			// Call {method.MethodName} hook
			result.Add({method.MethodName}({arguments}));
			""";
	}

	private static void ProcessValidatableProperty(
		PropertyProperties validatableProperty,
		ObjectProperties propertiesObject,
		EquatableArray<ValidatorProperties> validators,
		List<AttributeProperties> attributes,
		RulesClassBuilder rulesClassBuilder,
		CustomValidationInterfaceBuilder customValidationInterfaceBuilder,
		PropertiesValidationInvocationBuilder invocationBuilder
	)
	{
		var attributesWithValidators = new List<(AttributeProperties, ValidatorProperties)>(attributes.Count);
		var propertyCalls = new CallsCollection();

		foreach (var validationAttribute in attributes)
		{
			// CUSTOM validation
			if (validationAttribute.QualifiedName == Consts.CustomValidationAttribute)
			{
				customValidationInterfaceBuilder.AddCustomValidationForProperty(validatableProperty, propertyCalls);
				continue;
			}

			var validator = validators.FirstOrDefault(validator =>
				validator.QualifiedName == validationAttribute.QualifiedName
			);

			if (validator is null)
			{
				continue;
			}

			attributesWithValidators.Add((validationAttribute, validator));
		}

		// Generate RULE
		rulesClassBuilder.AddRuleForProperty(validatableProperty, attributesWithValidators);

		bool anyAsync =
			customValidationInterfaceBuilder.Calls.AnyAsync()
			|| (propertiesObject.BeforeValidateMethod?.ReturnTypeType & ReturnTypeType.Awaitable) != 0
			|| (propertiesObject.AfterValidateMethod?.ReturnTypeType & ReturnTypeType.Awaitable) != 0;

		// Generate INVOCATION
		invocationBuilder.AddInvocationForProperty(
			validatableProperty,
			attributesWithValidators,
			propertyCalls,
			anyAsync
		);
	}

	private static void AddAutoValidators(
		List<AttributeProperties> attributes,
		PropertyProperties validatableProperty,
		ValidlyConfiguration config,
		bool? useAutoValidators
	)
	{
		// Auto validators are disabled for this object, or it's a record's "EqualityContract" property
		if (useAutoValidators == false || validatableProperty.PropertyName == "EqualityContract")
		{
			return;
		}

		// Required - Add Required validator if the property is not nullable
		if (
			(useAutoValidators ?? config.AutoRequired)
			&& !validatableProperty.Nullable
			&& attributes.All(x => x.QualifiedName != Consts.RequiredAttributeQualifiedName)
			&& validatableProperty.PropertyTypeKind is not TypeKind.Enum and not TypeKind.Struct
		)
		{
			attributes.Add(AttributeProperties.Required);
		}

		// InEnum - Add InEnum validator for Enum properties
		if (
			(useAutoValidators ?? config.AutoInEnum)
			&& validatableProperty.PropertyTypeKind == TypeKind.Enum
			&& attributes.All(x => x.QualifiedName != Consts.InEnumAttributeQualifiedName)
		)
		{
			attributes.Add(AttributeProperties.InEnum);
		}
	}
}
